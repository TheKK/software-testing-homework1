* Triangle problem

  To make this assignment easier to impalement, let me assume that our function,
  caculateTriangleType, has following signature:

  TriangleType caculateTriangleType(int sideA, int sideB, int sideC)

  So basically, this function accepts three integers range from 1 to 200, and return
  an corresponding triangle type to the caller. Next, I'd like to write down some test
  cases created from the methods which mentioned in the class.

** Boundary values

   This function has three inputs with range from 1 to 200, its normal boundary value
   test case should be:

   *normal boundary (4 kinds x 3 variable = 12 test case)*

   | a |   1 |   2 | 199 | 200 | 100 | 100 | 100 | 100 | 100 | 100 | 100 | 100 |
   | b | 100 | 100 | 100 | 100 |   1 |   2 | 199 | 200 | 100 | 100 | 100 | 100 |
   | c | 100 | 100 | 100 | 100 | 100 | 100 | 100 | 100 |   1 |   2 | 199 | 200 |

   and below are more test values to make it *robust boundary (12 + 2 * 3 variables)* by adding it into
   *normal boundary*

   | a |   0 | 201 | 100 | 100 | 100 | 100 |
   | b | 100 | 100 |   0 | 201 | 100 | 100 |
   | c | 100 | 100 | 100 | 100 |   0 | 201 |

   to reject the assumption that each variable are independent, let's convert our
   test cases into *worst case boundary(6 * 6 + )*, by adding more test case into *normal
   boundary*

   | a |   1 |   1 |   1 |   1 |
   | b |   1 |   2 | 199 | 200 |
   | c | 100 | 100 | 100 | 100 |

   | a |   2 |   2 |   2 |   2 |
   | b |   1 |   2 | 199 | 200 |
   | c | 100 | 100 | 100 | 100 |

   | a | 199 | 199 | 199 | 199 |
   | b |   1 |   2 | 199 | 200 |
   | c | 100 | 100 | 100 | 100 |

   | a | 200 | 200 | 200 | 200 |
   | b |   1 |   2 | 199 | 200 |
   | c | 100 | 100 | 100 | 100 |

   | a | 1 | 2 | 199 | 200 |
   | b | 1 | 1 |   1 |   1 |
   | c | 1 | 1 |   1 |   1 |

   | a | 1 | 2 | 199 | 200 |
   | b | 2 | 2 |   2 |   2 |
   | c | 1 | 1 |   1 |   1 |

   | a | 1 | 1 |   1 |   1 |
   | b | 1 | 1 |   1 |   1 |
   | c | 1 | 2 | 199 | 200 |

   | a | 1 | 1 |   1 |   1 |
   | b | 2 | 2 |   2 |   2 |
   | c | 1 | 2 | 199 | 200 |

   | a |   1 |   1 |   1 |   1 |
   | b | 199 | 199 | 199 | 199 |
   | c |   1 |   2 | 199 | 200 |

   | a |   1 |   1 |   1 |   1 |
   | b | 200 | 200 | 200 | 200 |
   | c |   1 |   2 | 199 | 200 |

   | a | 2 | 2 |   2 |   2 |
   | b | 1 | 1 |   1 |   1 |
   | c | 1 | 2 | 199 | 200 |

   | a | 2 | 2 |   2 |   2 |
   | b | 2 | 2 |   2 |   2 |
   | c | 1 | 2 | 199 | 200 |

   | a |   2 |   2 |   2 |   2 |
   | b | 199 | 199 | 199 | 199 |
   | c |   1 |   2 | 199 | 200 |

   | a |   2 |   2 |   2 |   2 |
   | b | 200 | 200 | 200 | 200 |
   | c |   1 |   2 | 199 | 200 |

   | a | 199 | 199 | 199 | 199 |
   | b |   1 |   1 |   1 |   1 |
   | c |   1 |   2 | 199 | 200 |

   | a | 199 | 199 | 199 | 199 |
   | b |   2 |   2 |   2 |   2 |
   | c |   1 |   2 | 199 | 200 |

   | a | 199 | 199 | 199 | 199 |
   | b | 199 | 199 | 199 | 199 |
   | c |   1 |   2 | 199 | 200 |

   | a | 199 | 199 | 199 | 199 |
   | b | 200 | 200 | 200 | 200 |
   | c |   1 |   2 | 199 | 200 |

   | a | 200 | 200 | 200 | 200 |
   | b |   1 |   1 |   1 |   1 |
   | c |   1 |   2 | 199 | 200 |

   | a | 200 | 200 | 200 | 200 |
   | b |   2 |   2 |   2 |   2 |
   | c |   1 |   2 | 199 | 200 |

   | a | 200 | 200 | 200 | 200 |
   | b | 199 | 199 | 199 | 199 |
   | c |   1 |   2 | 199 | 200 |

   | a | 200 | 200 | 200 | 200 |
   | b | 200 | 200 | 200 | 200 |
   | c |   1 |   2 | 199 | 200 |

   Phew, there's already lot of them. I know it kind of lazy to skip some of them but
   hey, the rest of them are _redundant_, right? So let me just skip them.

   Finally, let add more test case into *worst case boundary* and make it become
   *robust worst case bondary*!

   | a |   0 |   0 | 201 | 201 | 0 | 201 |   0 | 201 | 201 |
   | b |   0 | 201 |   0 | 201 | 0 |   0 | 201 | 201 | 201 |
   | c | 100 | 100 | 100 | 100 | 0 |   0 |   0 |   0 | 201 |

   Still, I skip most of them here since they're just in different order. That's all of
   them, folks!

** Equivalence class

   First thing to do is define *classes*. In triangle problem one possible way is to
   classify test case by the *result*, means:

    - C1 = {a, b, c, which form an equilateral triangle}
    - C2 = {a, b, c, which form an isosceles triangle}
    - C3 = {a, b, c, which form an scalene triangle}
    - C4 = {a, b, c, which unable to form an triangle}

   Well, fair enough for this case. Let's write them down:

   *Weak normal*
   | a | 42 | 42 | 42 | 42 |
   | b | 42 | 42 | 41 |  9 |
   | c | 42 | 10 | 10 |  9 |

   *Weak robust (unable to create test case in C1)*
   | a |  0 | 201 |  0 | 201 |
   | b | 42 |  42 | 42 |  42 |
   | c | 42 |  42 | 41 |  41 |

   *Strong normal (since our classes are all mutual exclusive, it's impossible to
   find any strong normal test case)*
   | a | x |
   | b | x |
   | c | x |

   *Strong robust*
   | a |  0 | 0 | 201 | 201 |
   | b |  0 | 0 | 201 | 201 |
   | c | 42 | 0 |  42 | 201 |

   That's it! Thanks to equivalence class, we can find out a set of test cases which
   represent all the others shown in boundary value section. I'm not saying boundary
   test is useless, but in triangle problem we don't have to use them *all*. Testing
   edge case is still important.

** Edge testing

   If we define our equivalence class as below:

    - C1 = {a: 1 <= a <= 200}
    - C2 = {b: 1 <= a <= 200}
    - C3 = {c: 1 <= a <= 200}

   then edge case would be the same as boundary value test and that's not what we expected.
   But when we define our class as:

    - C1 = {a, b, c, which form an equilateral triangle}
    - C2 = {a, b, c, which form an isosceles triangle}
    - C3 = {a, b, c, which form an scalene triangle}
    - C4 = {a, b, c, which unable to form an triangle}

   It's actually weird to find its *edge*. So I decide to skip edge testing analysis since
   it doen't look like an good method for triangle problem.

** Decision table

   Decision table is an great way to analysis triangle problem.

   | a < b + c      | T | T | T | T | T | T | T | T | T | T | F |
   | b < a + c      | T | T | T | T | T | T | T | T | T | F | - |
   | c < a + b      | T | T | T | T | T | T | T | T | F | - | - |
   |----------------+---+---+---+---+---+---+---+---+---+---+---|
   | a == b         | T | T | F | F | F | T | T | F | - | - | - |
   | b == c         | T | F | T | F | T | F | T | F | - | - | - |
   | a == c         | T | F | F | T | T | T | F | F | - | - | - |
   |----------------+---+---+---+---+---+---+---+---+---+---+---|
   | Equivalence    | o |   |   |   |   |   |   |   |   |   |   |
   | Isosceles      |   | o | o | o |   |   |   |   |   |   |   |
   | Scalene        |   |   |   |   |   |   |   | o |   |   |   |
   | Not a triangle |   |   |   |   |   |   |   |   | o | o | o |
   | Impossible     |   |   |   |   | o | o | o |   |   |   |   |

   With this table, we can easily create corresponding test cases:

   *Equivalence triangle*
   | a | 42 |
   | b | 42 |
   | c | 42 |

   *Isosceles triangle*
   | a | 42 | 42 |  3 |
   | b | 42 |  3 | 42 |
   | c |  3 | 42 | 42 |

   *Scalene triangle*
   | a | 3 |
   | b | 4 |
   | c | 5 |

   *Not a triangle*
   | a | 100 |   3 |   3 |
   | b |   4 | 100 |   3 |
   | c |   5 |   2 | 100 |
   
** Conclusion
   
   So after all analysis, let recap some properties triangle problem has:

     - parameter order doesn't matter, we only care able an *set* of value
     - function result is decided by relation of each input
     - invalid input exist
    
   Due to the properties shown and my experience going through all analysis process, it's
   not hard to find out that:

     - boundary test have **too** much redundant testcase
     - it's not intuitive to find equivalence class
     - edge test is hard be done as well
     - decision table work quite well
      
   In my humble opinion, doing decision table was totally fine but not sufficient. We still
   need some tests to valid how our function react to invalid input(s). My question here
   would be that *could we assume that all three inputs are independent* and we don't have
   go through every test shown in boundary value testing ?

* NextDate problem
* Commission problem
